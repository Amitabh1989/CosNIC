"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(test_runner)/testcases/page",{

/***/ "(app-pages-browser)/./src/reduxToolkit/testCasesSlice.js":
/*!********************************************!*\
  !*** ./src/reduxToolkit/testCasesSlice.js ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchTestCases: function() { return /* binding */ fetchTestCases; },\n/* harmony export */   resetTestCases: function() { return /* binding */ resetTestCases; },\n/* harmony export */   setError: function() { return /* binding */ setError; },\n/* harmony export */   setLoading: function() { return /* binding */ setLoading; },\n/* harmony export */   setTestCases: function() { return /* binding */ setTestCases; }\n/* harmony export */ });\n/* harmony import */ var _api_test_cases_apis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/api/test_cases_apis */ \"(app-pages-browser)/./src/api/test_cases_apis.jsx\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _services_indexedDBService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/indexedDBService */ \"(app-pages-browser)/./src/services/indexedDBService.js\");\n// import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\n\n// // Thunk for fetching test cases asynchronously\n// export const fetchTestCases = createAsyncThunk(\n//     // \"testCases/fetchTestCases\",\n//     \"testCases/fetchTestCases\",\n//     async (_, { rejectWithValue }) => {\n//         console.log(\"fetchTestCases thunk called!\"); // Add this for debugging\n//         try {\n//             const response = await getTestCasesApi();\n//             console.log(\"Test cases response asyncThunk :\", response.data); // Debug response\n//             return response.data;\n//         } catch (error) {\n//             console.error(\"Error in fetchTestCases thunk:\", error); // Debug error\n//             return rejectWithValue(error.message);\n//         }\n//     }\n// );\n// const initialTestCasesState = {\n//     testCasesRecord: [], // Ensure this is an array\n//     isIndexed: false,\n//     loading: false, // Track loading state\n//     error: null, // Track errors\n// };\n// // Create testCases slice\n// const testCasesSlice = createSlice({\n//     name: \"testCases\",\n//     initialState: initialTestCasesState,\n//     reducers: {\n//         setTestCases: (state, action) => {\n//             state.testCasesRecord = action.payload; // Update test cases\n//             console.log(`Loaded testcasesRecord data`);\n//         },\n//         setIsTestCaseIndexed: (state, action) => {\n//             state.isIndexed = action.payload; // Update index flag\n//         },\n//     },\n//     extraReducers: (builder) => {\n//         builder\n//             .addCase(fetchTestCases.pending, (state) => {\n//                 state.loading = true;\n//                 state.error = null;\n//                 console.log(\"Fetching test cases, pending...\");\n//             })\n//             .addCase(fetchTestCases.fulfilled, (state, action) => {\n//                 state.testCasesRecord = action.payload;\n//                 state.isIndexed = true;\n//                 state.loading = false;\n//                 console.log(\n//                     `State is fulfilled : ${state.testCasesRecord.length}`\n//                 );\n//             })\n//             .addCase(fetchTestCases.rejected, (state, action) => {\n//                 state.loading = false;\n//                 // state.error = action.error.message;\n//                 state.error = action.payload || action.error.message;\n//                 console.error(\"Test cases fetching failed:\", state.error);\n//             });\n//     },\n// });\n// export const { setTestCases, setIsTestCaseIndexed } = testCasesSlice.actions;\n// export default testCasesSlice.reducer;\n// features/testCasesSlice.js\n\n\n// import Dexie from \"dexie\";\n// const db = new Dexie(\"CosNICDatabase\");\n// db.version(1).stores({\n//     testCases: \"++id, tcid, title, suite_name, applicable_os, stream, category\",\n// });\n//  [Violation] 'success' handler took 155ms\n// export async function batchInsert(data, batchSize = 100) {\n//     for (let i = 0; i < data.length; i += batchSize) {\n//         const batch = data.slice(i, i + batchSize);\n//         const existingRecords = await db.testCases\n//             .where(\"id\")\n//             .anyOf(batch.map((record) => record.id))\n//             .toArray();\n//         const existingIds = new Set(existingRecords.map((record) => record.id));\n//         const newBatch = batch.filter((item) => !existingIds.has(item.id));\n//         // Insert only new records\n//         if (newBatch.length > 0) {\n//             await db.testCases.bulkPut(newBatch);\n//         }\n//     }\n// }\n// Async thunk to fetch test cases\n/* This `fetchTestCases` function is an asynchronous thunk created using `createAsyncThunk` from Redux Toolkit. It is responsible for fetching test cases data either from the Redux store, IndexedDB, or an external API. */ // export const fetchTestCases = createAsyncThunk(\n//     \"testCases/fetchTestCases\",\n//     async (_, { getState, rejectWithValue }) => {\n//         // try {\n//         const state = getState();\n//         console.log(`GetState value in thunk : ${JSON.stringify(state)}`);\n//         const cachedTestCases = state.testCases;\n//         console.log(`Cached test case : ${cachedTestCases}`);\n//         // Check if data exists in Redux store\n//         if (cachedTestCases && cachedTestCases.length > 0) {\n//             console.log(\"Returning data from Redux store\");\n//             return cachedTestCases;\n//         }\n//         // Check IndexedDB\n//         // const indexedDbTestCases = await db.testCases.toArray(); // Corrected reference to the 'testcases' table\n//         // console.log(\n//         //     `indexedDbTestCases test case : ${indexedDbTestCases?.length}`\n//         // );\n//         // if (indexedDbTestCases?.length > 0) {\n//         //     console.log(\n//         //         \"Returning data from IndexedDB, num records : \",\n//         //         indexedDbTestCases.length\n//         //     );\n//         //     return indexedDbTestCases;\n//         // }\n//         // try {\n//         // Fetch from backend API if not found\n//         const response = await getTestCasesApi();\n//         console.log(`Response : ${response.status}`);\n//         if (response.status != 200) {\n//             return rejectWithValue(\"Network response was not ok\");\n//         }\n//         // Save to IndexedDB\n//         // await batchInsert(response.data);\n//         // await db.transaction(\"rw\", db.testcases, async () => {\n//         //     await db.testcases.bulkPut(data);\n//         // });\n//         return response.data;\n//     }\n// );\n// Async thunk to fetch test cases\n// export const fetchTestCases = createAsyncThunk(\n//     \"testCases/fetchTestCases\",\n//     async (_, { getState, rejectWithValue }) => {\n//         try {\n//             // 1. Check Redux store first (data already in memory)\n//             const state = getState();\n//             const cachedTestCases = state.testCases?.data;\n//             if (cachedTestCases && cachedTestCases.length > 0) {\n//                 console.log(\"Returning cached test cases from Redux store.\");\n//                 return cachedTestCases;\n//             }\n//             // 2. Check IndexedDB (if data is saved locally)\n//             const indexedDbTestCases = await db.testCases.toArray();\n//             if (indexedDbTestCases.length > 0) {\n//                 console.log(\"Returning test cases from IndexedDB.\");\n//                 return indexedDbTestCases;\n//             }\n//             // 3. Fetch from API (if no local data found)\n//             const response = await getTestCasesApi(); // Replace with actual API call\n//             if (response.status !== 200) {\n//                 throw new Error(\"Failed to fetch data from API\");\n//             }\n//             console.log(\"Fetched test cases from API.\");\n//             // 4. Save the fetched data to IndexedDB\n//             await batchInsert(response.data); // Insert into IndexedDB\n//             // Return the fresh data\n//             return response.data;\n//         } catch (error) {\n//             console.error(\"Error fetching test cases:\", error.message);\n//             return rejectWithValue(error.message);\n//         }\n//     }\n// );\nconst PAGE_SIZE = 50;\nconst fetchTestCases = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.createAsyncThunk)(\"testCases/fetchTestCases\", async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { getState, dispatch, rejectWithValue } = arguments.length > 1 ? arguments[1] : void 0;\n    try {\n        // 1. Check Redux store first if exists\n        // 2. Check IndexedDB\n        // const indexedDbTestCases = await db.testCases\n        //     .offset((page - 1) * PAGE_SIZE)\n        //     .limit(PAGE_SIZE)\n        //     .toArray();\n        // if (indexedDbTestCases.length > 0) {\n        //     console.log(\"Returning Test Cases from IndexedDB\");\n        //     return indexedDbTestCases;\n        // }\n        const indexedDbTestCases = await _services_indexedDBService__WEBPACK_IMPORTED_MODULE_1__[\"default\"].testCases.toArray();\n        if (indexedDbTestCases.length > 0) {\n            console.log(\"Returning Test Cases from IndexedDB\");\n            return indexedDbTestCases;\n        }\n        // 3. If data is not found anywhere, call api and get it\n        const response = await (0,_api_test_cases_apis__WEBPACK_IMPORTED_MODULE_0__.getTestCasesApi)(); // Replace with actual API call\n        if (response.status !== 200) {\n            throw new Error(\"Failed to fetch data from API\");\n        }\n        console.log(\"Fetched test cases from API for page \".concat(page, \".\"));\n        // 4. Save the fetched data to IndexedDB in chunks\n        await (0,_services_indexedDBService__WEBPACK_IMPORTED_MODULE_1__.batchInsert)(response.data); // Insert into IndexedDB\n        // Return the freshly fetched data for the current page\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching test cases:\", error.message);\n        return rejectWithValue(error.message);\n    }\n});\nconst testCasesSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.createSlice)({\n    name: \"testCases\",\n    initialState: {\n        data: [],\n        loading: false,\n        error: null,\n        isIndexed: false,\n        hasMore: true\n    },\n    reducers: {\n        setTestCases: (state, action)=>{\n            state.data = action.payload;\n            state.isIndexed = true;\n            console.log(\"Test case has been set\");\n        },\n        setLoading: (state, action)=>{\n            state.loading = action.payload;\n            console.log(\"Set loading is: \", action.payload);\n        },\n        setError: (state, action)=>{\n            state.error = action.payload;\n            state.loading = false;\n        },\n        resetTestCases: (state)=>{\n            state.data = [];\n            state.page = 1;\n            state.hasMore = true;\n        }\n    },\n    extraReducers: (builder)=>{\n        builder.addCase(fetchTestCases.pending, (state)=>{\n            state.loading = true;\n            state.error = null; // Reset errors on each fetch attempt\n        }).addCase(fetchTestCases.fulfilled, (state, action)=>{\n            if (action.payload.length === 0) {\n                state.hasMore = false; // No more data to load\n            }\n            // state.data = [...state.data, ...action.payload]; // Append the new batch of data\n            state.data = action.payload; // Append the new batch of data\n            state.loading = false;\n            state.isIndexed = true; // Set isIndexed to true if data is fetched\n        }).addCase(fetchTestCases.rejected, (state, action)=>{\n            state.loading = false;\n            state.error = action.payload || \"Failed to fetch test cases\";\n        });\n    }\n});\nconst { setTestCases, setLoading, setError, resetTestCases } = testCasesSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (testCasesSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eFRvb2xraXQvdGVzdENhc2VzU2xpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0U7QUFDWjtBQUV4RCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELHFDQUFxQztBQUNyQyxrQ0FBa0M7QUFDbEMsMENBQTBDO0FBQzFDLGlGQUFpRjtBQUNqRixnQkFBZ0I7QUFDaEIsd0RBQXdEO0FBQ3hELGdHQUFnRztBQUNoRyxvQ0FBb0M7QUFDcEMsNEJBQTRCO0FBQzVCLHFGQUFxRjtBQUNyRixxREFBcUQ7QUFDckQsWUFBWTtBQUNaLFFBQVE7QUFDUixLQUFLO0FBRUwsa0NBQWtDO0FBQ2xDLHNEQUFzRDtBQUN0RCx3QkFBd0I7QUFDeEIsNkNBQTZDO0FBQzdDLG1DQUFtQztBQUNuQyxLQUFLO0FBRUwsNEJBQTRCO0FBQzVCLHVDQUF1QztBQUN2Qyx5QkFBeUI7QUFDekIsMkNBQTJDO0FBQzNDLGtCQUFrQjtBQUNsQiw2Q0FBNkM7QUFDN0MsMkVBQTJFO0FBQzNFLDBEQUEwRDtBQUMxRCxhQUFhO0FBQ2IscURBQXFEO0FBQ3JELHFFQUFxRTtBQUNyRSxhQUFhO0FBQ2IsU0FBUztBQUNULG9DQUFvQztBQUNwQyxrQkFBa0I7QUFDbEIsNERBQTREO0FBQzVELHdDQUF3QztBQUN4QyxzQ0FBc0M7QUFDdEMsa0VBQWtFO0FBQ2xFLGlCQUFpQjtBQUNqQixzRUFBc0U7QUFDdEUsMERBQTBEO0FBQzFELDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLDZFQUE2RTtBQUM3RSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHFFQUFxRTtBQUNyRSx5Q0FBeUM7QUFDekMseURBQXlEO0FBQ3pELHdFQUF3RTtBQUN4RSw2RUFBNkU7QUFDN0Usa0JBQWtCO0FBQ2xCLFNBQVM7QUFDVCxNQUFNO0FBRU4sZ0ZBQWdGO0FBQ2hGLHlDQUF5QztBQUV6Qyw2QkFBNkI7QUFDb0M7QUFDRjtBQUMv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Q0FBQ25CLE1BQU0sS0FBSyxHQUFHO2dCQUM3QmlCLE1BQU1ILE9BQU8sR0FBRyxPQUFPLHVCQUF1QjtZQUNsRDtZQUNBLG1GQUFtRjtZQUNuRkcsTUFBTVgsSUFBSSxHQUFHWSxPQUFPQyxPQUFPLEVBQUUsK0JBQStCO1lBQzVERixNQUFNTCxPQUFPLEdBQUc7WUFDaEJLLE1BQU1KLFNBQVMsR0FBRyxNQUFNLDJDQUEyQztRQUN2RSxHQUNDWSxPQUFPLENBQUNqQyxlQUFlb0MsUUFBUSxFQUFFLENBQUNYLE9BQU9DO1lBQ3RDRCxNQUFNTCxPQUFPLEdBQUc7WUFDaEJLLE1BQU1WLEtBQUssR0FBR1csT0FBT0MsT0FBTyxJQUFJO1FBQ3BDO0lBQ1I7QUFDSjtBQUVPLE1BQU0sRUFBRUgsWUFBWSxFQUFFSSxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxFQUFFLEdBQy9EYixlQUFlb0IsT0FBTyxDQUFDO0FBQzNCLCtEQUFlcEIsZUFBZXFCLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcmVkdXhUb29sa2l0L3Rlc3RDYXNlc1NsaWNlLmpzP2UyNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHsgY3JlYXRlU2xpY2UsIGNyZWF0ZUFzeW5jVGh1bmsgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xyXG5pbXBvcnQgeyBnZXRUZXN0Q2FzZXNBcGkgfSBmcm9tIFwiQC9hcGkvdGVzdF9jYXNlc19hcGlzXCI7XHJcblxyXG4vLyAvLyBUaHVuayBmb3IgZmV0Y2hpbmcgdGVzdCBjYXNlcyBhc3luY2hyb25vdXNseVxyXG4vLyBleHBvcnQgY29uc3QgZmV0Y2hUZXN0Q2FzZXMgPSBjcmVhdGVBc3luY1RodW5rKFxyXG4vLyAgICAgLy8gXCJ0ZXN0Q2FzZXMvZmV0Y2hUZXN0Q2FzZXNcIixcclxuLy8gICAgIFwidGVzdENhc2VzL2ZldGNoVGVzdENhc2VzXCIsXHJcbi8vICAgICBhc3luYyAoXywgeyByZWplY3RXaXRoVmFsdWUgfSkgPT4ge1xyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKFwiZmV0Y2hUZXN0Q2FzZXMgdGh1bmsgY2FsbGVkIVwiKTsgLy8gQWRkIHRoaXMgZm9yIGRlYnVnZ2luZ1xyXG4vLyAgICAgICAgIHRyeSB7XHJcbi8vICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0VGVzdENhc2VzQXBpKCk7XHJcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGVzdCBjYXNlcyByZXNwb25zZSBhc3luY1RodW5rIDpcIiwgcmVzcG9uc2UuZGF0YSk7IC8vIERlYnVnIHJlc3BvbnNlXHJcbi8vICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4vLyAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBmZXRjaFRlc3RDYXNlcyB0aHVuazpcIiwgZXJyb3IpOyAvLyBEZWJ1ZyBlcnJvclxyXG4vLyAgICAgICAgICAgICByZXR1cm4gcmVqZWN0V2l0aFZhbHVlKGVycm9yLm1lc3NhZ2UpO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gKTtcclxuXHJcbi8vIGNvbnN0IGluaXRpYWxUZXN0Q2FzZXNTdGF0ZSA9IHtcclxuLy8gICAgIHRlc3RDYXNlc1JlY29yZDogW10sIC8vIEVuc3VyZSB0aGlzIGlzIGFuIGFycmF5XHJcbi8vICAgICBpc0luZGV4ZWQ6IGZhbHNlLFxyXG4vLyAgICAgbG9hZGluZzogZmFsc2UsIC8vIFRyYWNrIGxvYWRpbmcgc3RhdGVcclxuLy8gICAgIGVycm9yOiBudWxsLCAvLyBUcmFjayBlcnJvcnNcclxuLy8gfTtcclxuXHJcbi8vIC8vIENyZWF0ZSB0ZXN0Q2FzZXMgc2xpY2VcclxuLy8gY29uc3QgdGVzdENhc2VzU2xpY2UgPSBjcmVhdGVTbGljZSh7XHJcbi8vICAgICBuYW1lOiBcInRlc3RDYXNlc1wiLFxyXG4vLyAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsVGVzdENhc2VzU3RhdGUsXHJcbi8vICAgICByZWR1Y2Vyczoge1xyXG4vLyAgICAgICAgIHNldFRlc3RDYXNlczogKHN0YXRlLCBhY3Rpb24pID0+IHtcclxuLy8gICAgICAgICAgICAgc3RhdGUudGVzdENhc2VzUmVjb3JkID0gYWN0aW9uLnBheWxvYWQ7IC8vIFVwZGF0ZSB0ZXN0IGNhc2VzXHJcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgdGVzdGNhc2VzUmVjb3JkIGRhdGFgKTtcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIHNldElzVGVzdENhc2VJbmRleGVkOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4vLyAgICAgICAgICAgICBzdGF0ZS5pc0luZGV4ZWQgPSBhY3Rpb24ucGF5bG9hZDsgLy8gVXBkYXRlIGluZGV4IGZsYWdcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICAgIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XHJcbi8vICAgICAgICAgYnVpbGRlclxyXG4vLyAgICAgICAgICAgICAuYWRkQ2FzZShmZXRjaFRlc3RDYXNlcy5wZW5kaW5nLCAoc3RhdGUpID0+IHtcclxuLy8gICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSB0cnVlO1xyXG4vLyAgICAgICAgICAgICAgICAgc3RhdGUuZXJyb3IgPSBudWxsO1xyXG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGZXRjaGluZyB0ZXN0IGNhc2VzLCBwZW5kaW5nLi4uXCIpO1xyXG4vLyAgICAgICAgICAgICB9KVxyXG4vLyAgICAgICAgICAgICAuYWRkQ2FzZShmZXRjaFRlc3RDYXNlcy5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbi8vICAgICAgICAgICAgICAgICBzdGF0ZS50ZXN0Q2FzZXNSZWNvcmQgPSBhY3Rpb24ucGF5bG9hZDtcclxuLy8gICAgICAgICAgICAgICAgIHN0YXRlLmlzSW5kZXhlZCA9IHRydWU7XHJcbi8vICAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gZmFsc2U7XHJcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuLy8gICAgICAgICAgICAgICAgICAgICBgU3RhdGUgaXMgZnVsZmlsbGVkIDogJHtzdGF0ZS50ZXN0Q2FzZXNSZWNvcmQubGVuZ3RofWBcclxuLy8gICAgICAgICAgICAgICAgICk7XHJcbi8vICAgICAgICAgICAgIH0pXHJcbi8vICAgICAgICAgICAgIC5hZGRDYXNlKGZldGNoVGVzdENhc2VzLnJlamVjdGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4vLyAgICAgICAgICAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xyXG4vLyAgICAgICAgICAgICAgICAgLy8gc3RhdGUuZXJyb3IgPSBhY3Rpb24uZXJyb3IubWVzc2FnZTtcclxuLy8gICAgICAgICAgICAgICAgIHN0YXRlLmVycm9yID0gYWN0aW9uLnBheWxvYWQgfHwgYWN0aW9uLmVycm9yLm1lc3NhZ2U7XHJcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGVzdCBjYXNlcyBmZXRjaGluZyBmYWlsZWQ6XCIsIHN0YXRlLmVycm9yKTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcbi8vICAgICB9LFxyXG4vLyB9KTtcclxuXHJcbi8vIGV4cG9ydCBjb25zdCB7IHNldFRlc3RDYXNlcywgc2V0SXNUZXN0Q2FzZUluZGV4ZWQgfSA9IHRlc3RDYXNlc1NsaWNlLmFjdGlvbnM7XHJcbi8vIGV4cG9ydCBkZWZhdWx0IHRlc3RDYXNlc1NsaWNlLnJlZHVjZXI7XHJcblxyXG4vLyBmZWF0dXJlcy90ZXN0Q2FzZXNTbGljZS5qc1xyXG5pbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XHJcbmltcG9ydCBkYiwgeyBiYXRjaEluc2VydCB9IGZyb20gXCIuLi9zZXJ2aWNlcy9pbmRleGVkREJTZXJ2aWNlXCI7XHJcbi8vIGltcG9ydCBEZXhpZSBmcm9tIFwiZGV4aWVcIjtcclxuXHJcbi8vIGNvbnN0IGRiID0gbmV3IERleGllKFwiQ29zTklDRGF0YWJhc2VcIik7XHJcbi8vIGRiLnZlcnNpb24oMSkuc3RvcmVzKHtcclxuLy8gICAgIHRlc3RDYXNlczogXCIrK2lkLCB0Y2lkLCB0aXRsZSwgc3VpdGVfbmFtZSwgYXBwbGljYWJsZV9vcywgc3RyZWFtLCBjYXRlZ29yeVwiLFxyXG4vLyB9KTtcclxuXHJcbi8vICBbVmlvbGF0aW9uXSAnc3VjY2VzcycgaGFuZGxlciB0b29rIDE1NW1zXHJcbi8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYXRjaEluc2VydChkYXRhLCBiYXRjaFNpemUgPSAxMDApIHtcclxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XHJcbi8vICAgICAgICAgY29uc3QgYmF0Y2ggPSBkYXRhLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xyXG4vLyAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjb3JkcyA9IGF3YWl0IGRiLnRlc3RDYXNlc1xyXG4vLyAgICAgICAgICAgICAud2hlcmUoXCJpZFwiKVxyXG4vLyAgICAgICAgICAgICAuYW55T2YoYmF0Y2gubWFwKChyZWNvcmQpID0+IHJlY29yZC5pZCkpXHJcbi8vICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcbi8vICAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGV4aXN0aW5nUmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4gcmVjb3JkLmlkKSk7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IG5ld0JhdGNoID0gYmF0Y2guZmlsdGVyKChpdGVtKSA9PiAhZXhpc3RpbmdJZHMuaGFzKGl0ZW0uaWQpKTtcclxuLy8gICAgICAgICAvLyBJbnNlcnQgb25seSBuZXcgcmVjb3Jkc1xyXG4vLyAgICAgICAgIGlmIChuZXdCYXRjaC5sZW5ndGggPiAwKSB7XHJcbi8vICAgICAgICAgICAgIGF3YWl0IGRiLnRlc3RDYXNlcy5idWxrUHV0KG5ld0JhdGNoKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vIH1cclxuXHJcbi8vIEFzeW5jIHRodW5rIHRvIGZldGNoIHRlc3QgY2FzZXNcclxuLyogVGhpcyBgZmV0Y2hUZXN0Q2FzZXNgIGZ1bmN0aW9uIGlzIGFuIGFzeW5jaHJvbm91cyB0aHVuayBjcmVhdGVkIHVzaW5nIGBjcmVhdGVBc3luY1RodW5rYCBmcm9tIFJlZHV4IFRvb2xraXQuIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBmZXRjaGluZyB0ZXN0IGNhc2VzIGRhdGEgZWl0aGVyIGZyb20gdGhlIFJlZHV4IHN0b3JlLCBJbmRleGVkREIsIG9yIGFuIGV4dGVybmFsIEFQSS4gKi9cclxuLy8gZXhwb3J0IGNvbnN0IGZldGNoVGVzdENhc2VzID0gY3JlYXRlQXN5bmNUaHVuayhcclxuLy8gICAgIFwidGVzdENhc2VzL2ZldGNoVGVzdENhc2VzXCIsXHJcbi8vICAgICBhc3luYyAoXywgeyBnZXRTdGF0ZSwgcmVqZWN0V2l0aFZhbHVlIH0pID0+IHtcclxuLy8gICAgICAgICAvLyB0cnkge1xyXG4vLyAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuLy8gICAgICAgICBjb25zb2xlLmxvZyhgR2V0U3RhdGUgdmFsdWUgaW4gdGh1bmsgOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlKX1gKTtcclxuLy8gICAgICAgICBjb25zdCBjYWNoZWRUZXN0Q2FzZXMgPSBzdGF0ZS50ZXN0Q2FzZXM7XHJcbi8vICAgICAgICAgY29uc29sZS5sb2coYENhY2hlZCB0ZXN0IGNhc2UgOiAke2NhY2hlZFRlc3RDYXNlc31gKTtcclxuXHJcbi8vICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YSBleGlzdHMgaW4gUmVkdXggc3RvcmVcclxuLy8gICAgICAgICBpZiAoY2FjaGVkVGVzdENhc2VzICYmIGNhY2hlZFRlc3RDYXNlcy5sZW5ndGggPiAwKSB7XHJcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmV0dXJuaW5nIGRhdGEgZnJvbSBSZWR1eCBzdG9yZVwiKTtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRlc3RDYXNlcztcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIC8vIENoZWNrIEluZGV4ZWREQlxyXG4vLyAgICAgICAgIC8vIGNvbnN0IGluZGV4ZWREYlRlc3RDYXNlcyA9IGF3YWl0IGRiLnRlc3RDYXNlcy50b0FycmF5KCk7IC8vIENvcnJlY3RlZCByZWZlcmVuY2UgdG8gdGhlICd0ZXN0Y2FzZXMnIHRhYmxlXHJcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2coXHJcbi8vICAgICAgICAgLy8gICAgIGBpbmRleGVkRGJUZXN0Q2FzZXMgdGVzdCBjYXNlIDogJHtpbmRleGVkRGJUZXN0Q2FzZXM/Lmxlbmd0aH1gXHJcbi8vICAgICAgICAgLy8gKTtcclxuLy8gICAgICAgICAvLyBpZiAoaW5kZXhlZERiVGVzdENhc2VzPy5sZW5ndGggPiAwKSB7XHJcbi8vICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFxyXG4vLyAgICAgICAgIC8vICAgICAgICAgXCJSZXR1cm5pbmcgZGF0YSBmcm9tIEluZGV4ZWREQiwgbnVtIHJlY29yZHMgOiBcIixcclxuLy8gICAgICAgICAvLyAgICAgICAgIGluZGV4ZWREYlRlc3RDYXNlcy5sZW5ndGhcclxuLy8gICAgICAgICAvLyAgICAgKTtcclxuLy8gICAgICAgICAvLyAgICAgcmV0dXJuIGluZGV4ZWREYlRlc3RDYXNlcztcclxuLy8gICAgICAgICAvLyB9XHJcblxyXG4vLyAgICAgICAgIC8vIHRyeSB7XHJcbi8vICAgICAgICAgLy8gRmV0Y2ggZnJvbSBiYWNrZW5kIEFQSSBpZiBub3QgZm91bmRcclxuLy8gICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFRlc3RDYXNlc0FwaSgpO1xyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKGBSZXNwb25zZSA6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4vLyAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjAwKSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUoXCJOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2tcIik7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAvLyBTYXZlIHRvIEluZGV4ZWREQlxyXG4vLyAgICAgICAgIC8vIGF3YWl0IGJhdGNoSW5zZXJ0KHJlc3BvbnNlLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICAvLyBhd2FpdCBkYi50cmFuc2FjdGlvbihcInJ3XCIsIGRiLnRlc3RjYXNlcywgYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgICAgIC8vICAgICBhd2FpdCBkYi50ZXN0Y2FzZXMuYnVsa1B1dChkYXRhKTtcclxuLy8gICAgICAgICAvLyB9KTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbi8vICAgICB9XHJcbi8vICk7XHJcblxyXG4vLyBBc3luYyB0aHVuayB0byBmZXRjaCB0ZXN0IGNhc2VzXHJcbi8vIGV4cG9ydCBjb25zdCBmZXRjaFRlc3RDYXNlcyA9IGNyZWF0ZUFzeW5jVGh1bmsoXHJcbi8vICAgICBcInRlc3RDYXNlcy9mZXRjaFRlc3RDYXNlc1wiLFxyXG4vLyAgICAgYXN5bmMgKF8sIHsgZ2V0U3RhdGUsIHJlamVjdFdpdGhWYWx1ZSB9KSA9PiB7XHJcbi8vICAgICAgICAgdHJ5IHtcclxuLy8gICAgICAgICAgICAgLy8gMS4gQ2hlY2sgUmVkdXggc3RvcmUgZmlyc3QgKGRhdGEgYWxyZWFkeSBpbiBtZW1vcnkpXHJcbi8vICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuLy8gICAgICAgICAgICAgY29uc3QgY2FjaGVkVGVzdENhc2VzID0gc3RhdGUudGVzdENhc2VzPy5kYXRhO1xyXG4vLyAgICAgICAgICAgICBpZiAoY2FjaGVkVGVzdENhc2VzICYmIGNhY2hlZFRlc3RDYXNlcy5sZW5ndGggPiAwKSB7XHJcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJldHVybmluZyBjYWNoZWQgdGVzdCBjYXNlcyBmcm9tIFJlZHV4IHN0b3JlLlwiKTtcclxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRUZXN0Q2FzZXM7XHJcbi8vICAgICAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgICAgIC8vIDIuIENoZWNrIEluZGV4ZWREQiAoaWYgZGF0YSBpcyBzYXZlZCBsb2NhbGx5KVxyXG4vLyAgICAgICAgICAgICBjb25zdCBpbmRleGVkRGJUZXN0Q2FzZXMgPSBhd2FpdCBkYi50ZXN0Q2FzZXMudG9BcnJheSgpO1xyXG4vLyAgICAgICAgICAgICBpZiAoaW5kZXhlZERiVGVzdENhc2VzLmxlbmd0aCA+IDApIHtcclxuLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmV0dXJuaW5nIHRlc3QgY2FzZXMgZnJvbSBJbmRleGVkREIuXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWREYlRlc3RDYXNlcztcclxuLy8gICAgICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAgICAgLy8gMy4gRmV0Y2ggZnJvbSBBUEkgKGlmIG5vIGxvY2FsIGRhdGEgZm91bmQpXHJcbi8vICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0VGVzdENhc2VzQXBpKCk7IC8vIFJlcGxhY2Ugd2l0aCBhY3R1YWwgQVBJIGNhbGxcclxuLy8gICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XHJcbi8vICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIEFQSVwiKTtcclxuLy8gICAgICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJGZXRjaGVkIHRlc3QgY2FzZXMgZnJvbSBBUEkuXCIpO1xyXG5cclxuLy8gICAgICAgICAgICAgLy8gNC4gU2F2ZSB0aGUgZmV0Y2hlZCBkYXRhIHRvIEluZGV4ZWREQlxyXG4vLyAgICAgICAgICAgICBhd2FpdCBiYXRjaEluc2VydChyZXNwb25zZS5kYXRhKTsgLy8gSW5zZXJ0IGludG8gSW5kZXhlZERCXHJcblxyXG4vLyAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZyZXNoIGRhdGFcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbi8vICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHRlc3QgY2FzZXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gcmVqZWN0V2l0aFZhbHVlKGVycm9yLm1lc3NhZ2UpO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gKTtcclxuXHJcbmNvbnN0IFBBR0VfU0laRSA9IDUwO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZldGNoVGVzdENhc2VzID0gY3JlYXRlQXN5bmNUaHVuayhcclxuICAgIFwidGVzdENhc2VzL2ZldGNoVGVzdENhc2VzXCIsXHJcbiAgICBhc3luYyAocGFnZSA9IDEsIHsgZ2V0U3RhdGUsIGRpc3BhdGNoLCByZWplY3RXaXRoVmFsdWUgfSkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIDEuIENoZWNrIFJlZHV4IHN0b3JlIGZpcnN0IGlmIGV4aXN0c1xyXG5cclxuICAgICAgICAgICAgLy8gMi4gQ2hlY2sgSW5kZXhlZERCXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IGluZGV4ZWREYlRlc3RDYXNlcyA9IGF3YWl0IGRiLnRlc3RDYXNlc1xyXG4gICAgICAgICAgICAvLyAgICAgLm9mZnNldCgocGFnZSAtIDEpICogUEFHRV9TSVpFKVxyXG4gICAgICAgICAgICAvLyAgICAgLmxpbWl0KFBBR0VfU0laRSlcclxuICAgICAgICAgICAgLy8gICAgIC50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGlmIChpbmRleGVkRGJUZXN0Q2FzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJSZXR1cm5pbmcgVGVzdCBDYXNlcyBmcm9tIEluZGV4ZWREQlwiKTtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBpbmRleGVkRGJUZXN0Q2FzZXM7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgY29uc3QgaW5kZXhlZERiVGVzdENhc2VzID0gYXdhaXQgZGIudGVzdENhc2VzLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ZWREYlRlc3RDYXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJldHVybmluZyBUZXN0IENhc2VzIGZyb20gSW5kZXhlZERCXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWREYlRlc3RDYXNlcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMy4gSWYgZGF0YSBpcyBub3QgZm91bmQgYW55d2hlcmUsIGNhbGwgYXBpIGFuZCBnZXQgaXRcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRUZXN0Q2FzZXNBcGkoKTsgLy8gUmVwbGFjZSB3aXRoIGFjdHVhbCBBUEkgY2FsbFxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBkYXRhIGZyb20gQVBJXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGVkIHRlc3QgY2FzZXMgZnJvbSBBUEkgZm9yIHBhZ2UgJHtwYWdlfS5gKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDQuIFNhdmUgdGhlIGZldGNoZWQgZGF0YSB0byBJbmRleGVkREIgaW4gY2h1bmtzXHJcbiAgICAgICAgICAgIGF3YWl0IGJhdGNoSW5zZXJ0KHJlc3BvbnNlLmRhdGEpOyAvLyBJbnNlcnQgaW50byBJbmRleGVkREJcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZnJlc2hseSBmZXRjaGVkIGRhdGEgZm9yIHRoZSBjdXJyZW50IHBhZ2VcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHRlc3QgY2FzZXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0V2l0aFZhbHVlKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IHRlc3RDYXNlc1NsaWNlID0gY3JlYXRlU2xpY2Uoe1xyXG4gICAgbmFtZTogXCJ0ZXN0Q2FzZXNcIixcclxuICAgIGluaXRpYWxTdGF0ZToge1xyXG4gICAgICAgIGRhdGE6IFtdLCAvLyBTdG9yZXMgdGVzdCBjYXNlIGRhdGFcclxuICAgICAgICBsb2FkaW5nOiBmYWxzZSwgLy8gSW5kaWNhdGVzIGxvYWRpbmcgc3RhdGVcclxuICAgICAgICBlcnJvcjogbnVsbCwgLy8gSG9sZHMgYW55IGVycm9yc1xyXG4gICAgICAgIGlzSW5kZXhlZDogZmFsc2UsIC8vIEluZGljYXRlcyBpZiBkYXRhIGlzIHNhdmVkIGluIEluZGV4ZWREQlxyXG4gICAgICAgIGhhc01vcmU6IHRydWUsIC8vIFRyYWNrIGlmIHRoZXJlJ3MgbW9yZSBkYXRhIHRvIGxvYWRcclxuICAgIH0sXHJcbiAgICByZWR1Y2Vyczoge1xyXG4gICAgICAgIHNldFRlc3RDYXNlczogKHN0YXRlLCBhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgc3RhdGUuZGF0YSA9IGFjdGlvbi5wYXlsb2FkO1xyXG4gICAgICAgICAgICBzdGF0ZS5pc0luZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVGVzdCBjYXNlIGhhcyBiZWVuIHNldGApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0TG9hZGluZzogKHN0YXRlLCBhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgc3RhdGUubG9hZGluZyA9IGFjdGlvbi5wYXlsb2FkO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldCBsb2FkaW5nIGlzOiBcIiwgYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0RXJyb3I6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlLmVycm9yID0gYWN0aW9uLnBheWxvYWQ7XHJcbiAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0VGVzdENhc2VzOiAoc3RhdGUpID0+IHtcclxuICAgICAgICAgICAgc3RhdGUuZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBzdGF0ZS5wYWdlID0gMTtcclxuICAgICAgICAgICAgc3RhdGUuaGFzTW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xyXG4gICAgICAgIGJ1aWxkZXJcclxuICAgICAgICAgICAgLmFkZENhc2UoZmV0Y2hUZXN0Q2FzZXMucGVuZGluZywgKHN0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmVycm9yID0gbnVsbDsgLy8gUmVzZXQgZXJyb3JzIG9uIGVhY2ggZmV0Y2ggYXR0ZW1wdFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYWRkQ2FzZShmZXRjaFRlc3RDYXNlcy5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGFzTW9yZSA9IGZhbHNlOyAvLyBObyBtb3JlIGRhdGEgdG8gbG9hZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3RhdGUuZGF0YSA9IFsuLi5zdGF0ZS5kYXRhLCAuLi5hY3Rpb24ucGF5bG9hZF07IC8vIEFwcGVuZCB0aGUgbmV3IGJhdGNoIG9mIGRhdGFcclxuICAgICAgICAgICAgICAgIHN0YXRlLmRhdGEgPSBhY3Rpb24ucGF5bG9hZDsgLy8gQXBwZW5kIHRoZSBuZXcgYmF0Y2ggb2YgZGF0YVxyXG4gICAgICAgICAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNJbmRleGVkID0gdHJ1ZTsgLy8gU2V0IGlzSW5kZXhlZCB0byB0cnVlIGlmIGRhdGEgaXMgZmV0Y2hlZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYWRkQ2FzZShmZXRjaFRlc3RDYXNlcy5yZWplY3RlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmVycm9yID0gYWN0aW9uLnBheWxvYWQgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggdGVzdCBjYXNlc1wiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHsgc2V0VGVzdENhc2VzLCBzZXRMb2FkaW5nLCBzZXRFcnJvciwgcmVzZXRUZXN0Q2FzZXMgfSA9XHJcbiAgICB0ZXN0Q2FzZXNTbGljZS5hY3Rpb25zO1xyXG5leHBvcnQgZGVmYXVsdCB0ZXN0Q2FzZXNTbGljZS5yZWR1Y2VyO1xyXG4iXSwibmFtZXMiOlsiZ2V0VGVzdENhc2VzQXBpIiwiY3JlYXRlU2xpY2UiLCJjcmVhdGVBc3luY1RodW5rIiwiZGIiLCJiYXRjaEluc2VydCIsIlBBR0VfU0laRSIsImZldGNoVGVzdENhc2VzIiwicGFnZSIsImdldFN0YXRlIiwiZGlzcGF0Y2giLCJyZWplY3RXaXRoVmFsdWUiLCJpbmRleGVkRGJUZXN0Q2FzZXMiLCJ0ZXN0Q2FzZXMiLCJ0b0FycmF5IiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwic3RhdHVzIiwiRXJyb3IiLCJkYXRhIiwiZXJyb3IiLCJtZXNzYWdlIiwidGVzdENhc2VzU2xpY2UiLCJuYW1lIiwiaW5pdGlhbFN0YXRlIiwibG9hZGluZyIsImlzSW5kZXhlZCIsImhhc01vcmUiLCJyZWR1Y2VycyIsInNldFRlc3RDYXNlcyIsInN0YXRlIiwiYWN0aW9uIiwicGF5bG9hZCIsInNldExvYWRpbmciLCJzZXRFcnJvciIsInJlc2V0VGVzdENhc2VzIiwiZXh0cmFSZWR1Y2VycyIsImJ1aWxkZXIiLCJhZGRDYXNlIiwicGVuZGluZyIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwiYWN0aW9ucyIsInJlZHVjZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/reduxToolkit/testCasesSlice.js\n"));

/***/ })

});